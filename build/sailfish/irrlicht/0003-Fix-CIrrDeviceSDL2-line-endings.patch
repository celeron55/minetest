From 0b527e01c895196f6e37569c6a7beff2bf389347 Mon Sep 17 00:00:00 2001
From: Perttu Ahola <celeron55@gmail.com>
Date: Thu, 2 Jan 2014 22:35:02 +0200
Subject: [PATCH 3/8] Fix CIrrDeviceSDL2 line endings

---
 source/Irrlicht/CIrrDeviceSDL2.cpp | 2173 ++++++++++++++++++------------------
 source/Irrlicht/CIrrDeviceSDL2.h   |  480 ++++----
 2 files changed, 1329 insertions(+), 1324 deletions(-)

diff --git a/source/Irrlicht/CIrrDeviceSDL2.cpp b/source/Irrlicht/CIrrDeviceSDL2.cpp
index 2255b4e..1c47b5b 100644
--- a/source/Irrlicht/CIrrDeviceSDL2.cpp
+++ b/source/Irrlicht/CIrrDeviceSDL2.cpp
@@ -1,1084 +1,1089 @@
-// Copyright (C) 2002-2012 Nikolaus Gebhardt
-// This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in irrlicht.h
-
-#include "IrrCompileConfig.h"
-
-#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
-
-#include "CIrrDeviceSDL2.h"
-#include "IEventReceiver.h"
-#include "irrList.h"
-#include "os.h"
-#include "CTimer.h"
-#include "irrString.h"
-#include "Keycodes.h"
-#include "COSOperator.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include "SIrrCreationParameters.h"
-#include <SDL2/SDL_syswm.h>
-#include <SDL2/SDL_video.h>
-
-#include "CEGLManager.h" // Sailfish/c55
-#include <wayland-egl.h>
-
-namespace irr
-{
-	namespace video
-	{
-
-		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
-		IVideoDriver* createDirectX8Driver(const irr::SIrrlichtCreationParameters& params,
-			io::IFileSystem* io, HWND window);
-		#endif
-
-		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
-		IVideoDriver* createDirectX9Driver(const irr::SIrrlichtCreationParameters& params,
-			io::IFileSystem* io, HWND window);
-		#endif
-
-		#ifdef _IRR_COMPILE_WITH_OPENGL_
-		IVideoDriver* createOpenGLDriver(const SIrrlichtCreationParameters& params,
-				io::IFileSystem* io, CIrrDeviceSDL2* device);
-		#endif
-
-        #ifdef _IRR_COMPILE_WITH_OGLES2_ 	 
-        //IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, video::SExposedVideoData& data, io::IFileSystem* io);
-        IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager);
-        #endif
-	} // end namespace video
-
-} // end namespace irr
-
-
-namespace irr
-{
-
-//! constructor
-CIrrDeviceSDL2::CIrrDeviceSDL2(const SIrrlichtCreationParameters& param)
-	: CIrrDeviceStub(param),
-	Sdl2Window((SDL_Window*)param.WindowId), SDL_Flags(SDL_WINDOW_SHOWN),
-	MouseX(0), MouseY(0), MouseButtonStates(0),
-	Width(param.WindowSize.Width), Height(param.WindowSize.Height),
-	Resizable(false), WindowHasFocus(false), WindowMinimized(false)
-{
-	#ifdef _DEBUG
-	setDebugName("CIrrDeviceSDL2");
-	#endif
-
-	// Initialize SDL... Timer for sleep, video for the obvious, and
-	// noparachute prevents SDL from catching fatal errors.
-	if (SDL_Init( SDL_INIT_TIMER|SDL_INIT_VIDEO|
-#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
-				SDL_INIT_JOYSTICK|
-#endif
-				SDL_INIT_NOPARACHUTE ) < 0)
-	{
-		os::Printer::log( "Unable to initialize SDL!", SDL_GetError());
-		Close = true;
-	}
-
-/*#if defined(_IRR_WINDOWS_)
-	SDL_putenv("SDL_VIDEODRIVER=directx");
-#elif defined(_IRR_OSX_PLATFORM_)
-	SDL_putenv("SDL_VIDEODRIVER=Quartz");
-#else
-	SDL_putenv("SDL_VIDEODRIVER=x11");
-#endif*/
-//	SDL_putenv("SDL_WINDOWID=");
-
-	SDL_VERSION(&Info.version);
-
-	core::stringc sdlversion = "SDL Version ";
-	sdlversion += Info.version.major;
-	sdlversion += ".";
-	sdlversion += Info.version.minor;
-	sdlversion += ".";
-	sdlversion += Info.version.patch;
-
-	Operator = new COSOperator(sdlversion);
-	os::Printer::log(sdlversion.c_str(), ELL_INFORMATION);
-
-	os::Printer::log((core::stringc("SDL2: Number of displays: ")+
-			core::stringc(SDL_GetNumVideoDisplays())).c_str(), ELL_INFORMATION);
-		
-	for(int i=0; i<SDL_GetNumVideoDisplays(); i++){
-		for(int j=0; j<SDL_GetNumDisplayModes(i); j++){
-			SDL_DisplayMode m;
-			SDL_GetDisplayMode(i, j, &m);
-			os::Printer::log((core::stringc("Display ")+core::stringc(i)+
-					core::stringc(" mode ")+core::stringc(j)+
-					core::stringc(": ")+core::stringc(m.w)+
-					core::stringc("x")+core::stringc(m.h)).c_str(), ELL_INFORMATION);
-		}
-	}
-
-	// create keymap
-	createKeyMap();
-
-	if ( CreationParams.Fullscreen )
-		//SDL_Flags |= SDL_WINDOW_FULLSCREEN;
-		SDL_Flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
-	if (CreationParams.DriverType == video::EDT_OPENGL)
-		SDL_Flags |= SDL_WINDOW_OPENGL;
-
-	// create window
-	if (CreationParams.DriverType != video::EDT_NULL)
-	{
-		// create the window, only if we do not use the null device
-		createWindow();
-	}
-
-	// create cursor control
-	CursorControl = new CCursorControl(this);
-
-	// create driver
-	createDriver();
-
-	if (VideoDriver)
-		createGUIAndScene();
-}
-
-
-//! destructor
-CIrrDeviceSDL2::~CIrrDeviceSDL2()
-{
-#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
-	const u32 numJoysticks = Joysticks.size();
-	for (u32 i=0; i<numJoysticks; ++i)
-		SDL_JoystickClose(Joysticks[i]);
-#endif
-	SDL_Quit();
-}
-
-static SDL_Window* createSDL2Window(int w, int h, Uint32 flags)
-{
-	return SDL_CreateWindow("Irrlicht/SDL2", SDL_WINDOWPOS_UNDEFINED,
-			SDL_WINDOWPOS_UNDEFINED, w, h, flags);
-}
-
-bool CIrrDeviceSDL2::createWindow()
-{
-	if ( Close )
-		return false;
-
-	if (CreationParams.DriverType == video::EDT_OPENGL)
-	{
-		if (CreationParams.Bits==16)
-		{
-			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 4 );
-			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 4 );
-			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 4 );
-			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?1:0 );
-		}
-		else
-		{
-			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
-			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
-			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
-			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?8:0 );
-		}
-		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, CreationParams.ZBufferBits);
-		if (CreationParams.Doublebuffer)
-			SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
-		if (CreationParams.Stereobuffer)
-			SDL_GL_SetAttribute( SDL_GL_STEREO, 1 );
-		if (CreationParams.AntiAlias>1)
-		{
-			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 1 );
-			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
-		}
-		if ( !Sdl2Window )
-			Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
-		if ( !Sdl2Window && CreationParams.AntiAlias>1)
-		{
-			while (--CreationParams.AntiAlias>1)
-			{
-				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
-				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
-				if (Sdl2Window)
-					break;
-			}
-			if ( !Sdl2Window )
-			{
-				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 0 );
-				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, 0 );
-				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
-				if (Sdl2Window)
-					os::Printer::log("AntiAliasing disabled due to lack of support!" );
-			}
-		}
-	}
-	else if ( !Sdl2Window )
-		Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
-
-	if ( !Sdl2Window )
-	{
-		os::Printer::log( "Could not initialize display!" );
-		return false;
-	}
-
-	SDL_GetWindowWMInfo(Sdl2Window, &Info);
-	return true;
-}
-
-
-//! create the driver
-void CIrrDeviceSDL2::createDriver()
-{
-	os::Printer::log("CIrrDeviceSDL2::createDriver()", ELL_INFORMATION);
-	switch(CreationParams.DriverType)
-	{
-	case video::EDT_DIRECT3D8:
-		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
-
-		VideoDriver = video::createDirectX8Driver(CreationParams, FileSystem, HWnd);
-		if (!VideoDriver)
-		{
-			os::Printer::log("Could not create DIRECT3D8 Driver.", ELL_ERROR);
-		}
-		#else
-		os::Printer::log("DIRECT3D8 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
-		#endif // _IRR_COMPILE_WITH_DIRECT3D_8_
-
-		break;
-
-	case video::EDT_DIRECT3D9:
-		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
-
-		VideoDriver = video::createDirectX9Driver(CreationParams, FileSystem, HWnd);
-		if (!VideoDriver)
-		{
-			os::Printer::log("Could not create DIRECT3D9 Driver.", ELL_ERROR);
-		}
-		#else
-		os::Printer::log("DIRECT3D9 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
-		#endif // _IRR_COMPILE_WITH_DIRECT3D_9_
-
-		break;
-
-	case video::EDT_SOFTWARE:
-		#ifdef _IRR_COMPILE_WITH_SOFTWARE_
-		VideoDriver = video::createSoftwareDriver(CreationParams.WindowSize, CreationParams.Fullscreen, FileSystem, this);
-		#else
-		os::Printer::log("No Software driver support compiled in.", ELL_ERROR);
-		#endif
-		break;
-
-	case video::EDT_BURNINGSVIDEO:
-		#ifdef _IRR_COMPILE_WITH_BURNINGSVIDEO_
-		VideoDriver = video::createBurningVideoDriver(CreationParams, FileSystem, this);
-		#else
-		os::Printer::log("Burning's video driver was not compiled in.", ELL_ERROR);
-		#endif
-		break;
-
-	case video::EDT_OPENGL:
-		#ifdef _IRR_COMPILE_WITH_OPENGL_
-		VideoDriver = video::createOpenGLDriver(CreationParams, FileSystem, this);
-		#else
-		os::Printer::log("No OpenGL support compiled in.", ELL_ERROR);
-		#endif
-		break;
-
-    case video::EDT_OGLES2: 	 
-        #ifdef _IRR_COMPILE_WITH_OGLES2_
-        {
-            video::SExposedVideoData data;
-			switch(Info.subsystem){
-			case SDL_SYSWM_X11:
-				os::Printer::log("Subsystem for sdl2/ogles2: X11", ELL_INFORMATION);
-			#if defined(SDL_VIDEO_DRIVER_X11)
-				data.OpenGLLinux.X11Window = Info.info.x11.window; // Should be wl_egl_window
-				data.OpenGLLinux.X11Display = Info.info.x11.display;
-			#else
-				os::Printer::log("Subsystem for sdl2/ogles2: X11: not supported", ELL_ERROR);
-			#endif
-				break;
-			case SDL_SYSWM_WAYLAND: {
-				os::Printer::log("Subsystem for sdl2/ogles2: Wayland", ELL_INFORMATION);
-			#if defined(SDL_VIDEO_DRIVER_WAYLAND)
-				void *egl_window = wl_egl_window_create(Info.info.wl.surface, Width, Height);
-				if(!egl_window){
-					os::Printer::log("Wayland: Failed to create EGL window", ELL_ERROR);
-					Close = true;
-					return;
-				}
-				//data.OpenGLLinux.X11Window = (long unsigned int)Info.info.wl.surface; // Should be wl_egl_window
-				data.OpenGLLinux.X11Window = (long unsigned int)egl_window;
-				data.OpenGLLinux.X11Display = Info.info.wl.display;
-			#else
-				os::Printer::log("Subsystem for sdl2/ogles2: Wayland: not supported", ELL_ERROR);
-			#endif
-				break; }
-			case SDL_SYSWM_UNKNOWN:
-				os::Printer::log("Subsystem for sdl2/ogles2: SDL reports unknown: "
-						"not supported", ELL_ERROR);
-				break;
-			default:
-				os::Printer::log("Subsystem for sdl2/ogles2: Unimplemented",
-						ELL_INFORMATION);
-			}
-            ContextManager = new video::CEGLManager();
-			ContextManager->initialize(CreationParams, data);
-            VideoDriver = video::createOGLES2Driver(CreationParams, FileSystem, ContextManager);
-        }
-        #else
-        os::Printer::log("No OpenGL-ES2 support compiled in.", ELL_ERROR); 	 
-        #endif 	 
-        break;
-
-	case video::EDT_NULL:
-		VideoDriver = video::createNullDriver(FileSystem, CreationParams.WindowSize);
-		break;
-
-	default:
-		os::Printer::log("Unable to create video driver of unknown type.", ELL_ERROR);
-		break;
-	}
-}
-
-
-//! runs the device. Returns false if device wants to be deleted
-bool CIrrDeviceSDL2::run()
-{
-	os::Timer::tick();
-
-	SEvent irrevent;
-	SDL_Event SDL_event;
-
-	while ( !Close && SDL_PollEvent( &SDL_event ) )
-	{
-		switch ( SDL_event.type )
-		{
-		case SDL_FINGERDOWN:
-		case SDL_FINGERUP:
-		case SDL_FINGERMOTION:
-			{
-				// TODO: Implement properly
-				irrevent.EventType = EET_MULTI_TOUCH_EVENT;
-				irrevent.MultiTouchInput.clear();
-				bool Touched = false;
-				switch (SDL_event.type)
-				{
-				case SDL_FINGERDOWN:
-					irrevent.MultiTouchInput.Event = EMTIE_PRESSED_DOWN;
-					Touched = true;
-					break;
-				case SDL_FINGERUP:
-					irrevent.MultiTouchInput.Event = EMTIE_LEFT_UP;
-					break;
-				case SDL_FINGERMOTION:
-					irrevent.MultiTouchInput.Event = EMTIE_MOVED;
-					Touched = true;
-					break;
-				default:
-					break;
-				}
-				int i = 0;
-				irrevent.MultiTouchInput.PrevX[i] = 0; // TODO
-				irrevent.MultiTouchInput.PrevY[i] = 0; // TODO
-				irrevent.MultiTouchInput.X[i] = SDL_event.tfinger.x;
-				irrevent.MultiTouchInput.Y[i] = SDL_event.tfinger.y;
-				irrevent.MultiTouchInput.Touched[i] = Touched;
-				postEventFromUser(irrevent);
-
-				irrevent = SEvent(); // clear
-				irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
-				switch (SDL_event.type)
-				{
-				case SDL_FINGERDOWN:
-					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
-					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
-					break;
-				case SDL_FINGERUP:
-					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
-					break;
-				case SDL_FINGERMOTION:
-					irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
-					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
-					break;
-				default:
-					break;
-				}
-				MouseX = irrevent.MouseInput.X = SDL_event.tfinger.x;
-				MouseY = irrevent.MouseInput.Y = SDL_event.tfinger.y;
-				postEventFromUser(irrevent);
-			}
-
-			SDL_StartTextInput(); // Test
-			break;
-
-		case SDL_MOUSEMOTION:
-			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
-			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
-			MouseX = irrevent.MouseInput.X = SDL_event.motion.x;
-			MouseY = irrevent.MouseInput.Y = SDL_event.motion.y;
-			irrevent.MouseInput.ButtonStates = MouseButtonStates;
-
-			postEventFromUser(irrevent);
-			break;
-
-		case SDL_MOUSEBUTTONDOWN:
-		case SDL_MOUSEBUTTONUP:
-
-			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
-			irrevent.MouseInput.X = SDL_event.button.x;
-			irrevent.MouseInput.Y = SDL_event.button.y;
-
-			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
-
-			switch(SDL_event.button.button)
-			{
-			case SDL_BUTTON_LEFT:
-				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
-				{
-					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
-					MouseButtonStates |= irr::EMBSM_LEFT;
-				}
-				else
-				{
-					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
-					MouseButtonStates &= !irr::EMBSM_LEFT;
-				}
-				break;
-
-			case SDL_BUTTON_RIGHT:
-				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
-				{
-					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_PRESSED_DOWN;
-					MouseButtonStates |= irr::EMBSM_RIGHT;
-				}
-				else
-				{
-					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_LEFT_UP;
-					MouseButtonStates &= !irr::EMBSM_RIGHT;
-				}
-				break;
-
-			case SDL_BUTTON_MIDDLE:
-				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
-				{
-					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_PRESSED_DOWN;
-					MouseButtonStates |= irr::EMBSM_MIDDLE;
-				}
-				else
-				{
-					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_LEFT_UP;
-					MouseButtonStates &= !irr::EMBSM_MIDDLE;
-				}
-				break;
-
-			/* TODO: Move to SDL_MOUSEWHEEL events
-			case SDL_BUTTON_WHEELUP:
-				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
-				irrevent.MouseInput.Wheel = 1.0f;
-				break;
-
-			case SDL_BUTTON_WHEELDOWN:
-				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
-				irrevent.MouseInput.Wheel = -1.0f;
-				break;*/
-			}
-
-			irrevent.MouseInput.ButtonStates = MouseButtonStates;
-
-			if (irrevent.MouseInput.Event != irr::EMIE_MOUSE_MOVED)
-			{
-				postEventFromUser(irrevent);
-
-				if ( irrevent.MouseInput.Event >= EMIE_LMOUSE_PRESSED_DOWN && irrevent.MouseInput.Event <= EMIE_MMOUSE_PRESSED_DOWN )
-				{
-					u32 clicks = checkSuccessiveClicks(irrevent.MouseInput.X, irrevent.MouseInput.Y, irrevent.MouseInput.Event);
-					if ( clicks == 2 )
-					{
-						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_DOUBLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
-						postEventFromUser(irrevent);
-					}
-					else if ( clicks == 3 )
-					{
-						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_TRIPLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
-						postEventFromUser(irrevent);
-					}
-				}
-			}
-			break;
-
-		case SDL_KEYDOWN:
-		case SDL_KEYUP:
-			{
-				SKeyMap mp;
-				mp.SDLKey = SDL_event.key.keysym.sym;
-				s32 idx = KeyMap.binary_search(mp);
-
-				EKEY_CODE key;
-				if (idx == -1)
-					key = (EKEY_CODE)0;
-				else
-					key = (EKEY_CODE)KeyMap[idx].Win32Key;
-
-#ifdef _IRR_WINDOWS_API_
-				// handle alt+f4 in Windows, because SDL seems not to
-				if ( (SDL_event.key.keysym.mod & KMOD_LALT) && key == KEY_F4)
-				{
-					Close = true;
-					break;
-				}
-#endif
-				irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
-				irrevent.KeyInput.Char = SDL_event.key.keysym.unicode;
-				irrevent.KeyInput.Key = key;
-				irrevent.KeyInput.PressedDown = (SDL_event.type == SDL_KEYDOWN);
-				irrevent.KeyInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
-				irrevent.KeyInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL ) != 0;
-				postEventFromUser(irrevent);
-			}
-			break;
-
-		case SDL_QUIT:
-			Close = true;
-			break;
-
-		case SDL_WINDOWEVENT:
-			switch (SDL_event.window.event) {
-			case SDL_WINDOWEVENT_SHOWN:
-				WindowMinimized = false;
-				break;
-			case SDL_WINDOWEVENT_HIDDEN:
-				break;
-			case SDL_WINDOWEVENT_EXPOSED:
-				WindowMinimized = false;
-				break;
-			case SDL_WINDOWEVENT_MOVED:
-				break;
-			case SDL_WINDOWEVENT_RESIZED:
-				// NOTE: Can be other window
-				Width = SDL_event.window.data1;
-				Height = SDL_event.window.data2;
-				// TODO: Is this needed?
-				//Sdl2Window = createSDL2Window( Width, Height, 0, SDL_Flags );
-				if (VideoDriver)
-					VideoDriver->OnResize(core::dimension2d<u32>(Width, Height));
-				break;
-			case SDL_WINDOWEVENT_MINIMIZED:
-				WindowMinimized = true;
-				break;
-			case SDL_WINDOWEVENT_MAXIMIZED:
-				WindowMinimized = false;
-				break;
-			case SDL_WINDOWEVENT_RESTORED:
-				WindowMinimized = false;
-				break;
-			case SDL_WINDOWEVENT_ENTER:
-				break;
-			case SDL_WINDOWEVENT_LEAVE:
-				break;
-			case SDL_WINDOWEVENT_FOCUS_GAINED:
-				WindowHasFocus = true;
-				break;
-			case SDL_WINDOWEVENT_FOCUS_LOST:
-				WindowHasFocus = false;
-				break;
-			case SDL_WINDOWEVENT_CLOSE:
-				break;
-			default:
-				break;
-			}
-			break;
-
-		case SDL_USEREVENT:
-			irrevent.EventType = irr::EET_USER_EVENT;
-			irrevent.UserEvent.UserData1 = *(reinterpret_cast<s32*>(&SDL_event.user.data1));
-			irrevent.UserEvent.UserData2 = *(reinterpret_cast<s32*>(&SDL_event.user.data2));
-
-			postEventFromUser(irrevent);
-			break;
-
-		default:
-			break;
-		} // end switch
-
-	} // end while
-
-#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
-	// TODO: Check if the multiple open/close calls are too expensive, then
-	// open/close in the constructor/destructor instead
-
-	// update joystick states manually
-	SDL_JoystickUpdate();
-	// we'll always send joystick input events...
-	SEvent joyevent;
-	joyevent.EventType = EET_JOYSTICK_INPUT_EVENT;
-	for (u32 i=0; i<Joysticks.size(); ++i)
-	{
-		SDL_Joystick* joystick = Joysticks[i];
-		if (joystick)
-		{
-			int j;
-			// query all buttons
-			const int numButtons = core::min_(SDL_JoystickNumButtons(joystick), 32);
-			joyevent.JoystickEvent.ButtonStates=0;
-			for (j=0; j<numButtons; ++j)
-				joyevent.JoystickEvent.ButtonStates |= (SDL_JoystickGetButton(joystick, j)<<j);
-
-			// query all axes, already in correct range
-			const int numAxes = core::min_(SDL_JoystickNumAxes(joystick), SEvent::SJoystickEvent::NUMBER_OF_AXES);
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_X]=0;
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Y]=0;
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Z]=0;
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_R]=0;
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_U]=0;
-			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_V]=0;
-			for (j=0; j<numAxes; ++j)
-				joyevent.JoystickEvent.Axis[j] = SDL_JoystickGetAxis(joystick, j);
-
-			// we can only query one hat, SDL only supports 8 directions
-			if (SDL_JoystickNumHats(joystick)>0)
-			{
-				switch (SDL_JoystickGetHat(joystick, 0))
-				{
-					case SDL_HAT_UP:
-						joyevent.JoystickEvent.POV=0;
-						break;
-					case SDL_HAT_RIGHTUP:
-						joyevent.JoystickEvent.POV=4500;
-						break;
-					case SDL_HAT_RIGHT:
-						joyevent.JoystickEvent.POV=9000;
-						break;
-					case SDL_HAT_RIGHTDOWN:
-						joyevent.JoystickEvent.POV=13500;
-						break;
-					case SDL_HAT_DOWN:
-						joyevent.JoystickEvent.POV=18000;
-						break;
-					case SDL_HAT_LEFTDOWN:
-						joyevent.JoystickEvent.POV=22500;
-						break;
-					case SDL_HAT_LEFT:
-						joyevent.JoystickEvent.POV=27000;
-						break;
-					case SDL_HAT_LEFTUP:
-						joyevent.JoystickEvent.POV=31500;
-						break;
-					case SDL_HAT_CENTERED:
-					default:
-						joyevent.JoystickEvent.POV=65535;
-						break;
-				}
-			}
-			else
-			{
-				joyevent.JoystickEvent.POV=65535;
-			}
-
-			// we map the number directly
-			joyevent.JoystickEvent.Joystick=static_cast<u8>(i);
-			// now post the event
-			postEventFromUser(joyevent);
-			// and close the joystick
-		}
-	}
-#endif
-	return !Close;
-}
-
-//! Activate any joysticks, and generate events for them.
-bool CIrrDeviceSDL2::activateJoysticks(core::array<SJoystickInfo> & joystickInfo)
-{
-#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
-	joystickInfo.clear();
-
-	// we can name up to 256 different joysticks
-	const int numJoysticks = core::min_(SDL_NumJoysticks(), 256);
-	Joysticks.reallocate(numJoysticks);
-	joystickInfo.reallocate(numJoysticks);
-
-	int joystick = 0;
-	for (; joystick<numJoysticks; ++joystick)
-	{
-		Joysticks.push_back(SDL_JoystickOpen(joystick));
-		SJoystickInfo info;
-
-		info.Joystick = joystick;
-		info.Axes = SDL_JoystickNumAxes(Joysticks[joystick]);
-		info.Buttons = SDL_JoystickNumButtons(Joysticks[joystick]);
-		info.Name = SDL_JoystickName(joystick);
-		info.PovHat = (SDL_JoystickNumHats(Joysticks[joystick]) > 0)
-						? SJoystickInfo::POV_HAT_PRESENT : SJoystickInfo::POV_HAT_ABSENT;
-
-		joystickInfo.push_back(info);
-	}
-
-	for(joystick = 0; joystick < (int)joystickInfo.size(); ++joystick)
-	{
-		char logString[256];
-		(void)sprintf(logString, "Found joystick %d, %d axes, %d buttons '%s'",
-		joystick, joystickInfo[joystick].Axes,
-		joystickInfo[joystick].Buttons, joystickInfo[joystick].Name.c_str());
-		os::Printer::log(logString, ELL_INFORMATION);
-	}
-
-	return true;
-
-#endif // _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
-
-	return false;
-}
-
-
-
-//! pause execution temporarily
-void CIrrDeviceSDL2::yield()
-{
-	SDL_Delay(0);
-}
-
-
-//! pause execution for a specified time
-void CIrrDeviceSDL2::sleep(u32 timeMs, bool pauseTimer)
-{
-	const bool wasStopped = Timer ? Timer->isStopped() : true;
-	if (pauseTimer && !wasStopped)
-		Timer->stop();
-
-	SDL_Delay(timeMs);
-
-	if (pauseTimer && !wasStopped)
-		Timer->start();
-}
-
-
-//! sets the caption of the window
-void CIrrDeviceSDL2::setWindowCaption(const wchar_t* text)
-{
-	core::stringc textc = text;
-	SDL_SetWindowTitle(Sdl2Window, textc.c_str());
-}
-
-
-//! presents a surface in the client area
-bool CIrrDeviceSDL2::present(video::IImage* surface, void* windowId, core::rect<s32>* srcClip)
-{
-	SDL_Surface *sdlSurface = SDL_CreateRGBSurfaceFrom(
-			surface->lock(), surface->getDimension().Width, surface->getDimension().Height,
-			surface->getBitsPerPixel(), surface->getPitch(),
-			surface->getRedMask(), surface->getGreenMask(), surface->getBlueMask(), surface->getAlphaMask());
-	if (!sdlSurface)
-		return false;
-	//SDL_SetAlpha(sdlSurface, 0, 0);
-	SDL_SetColorKey(sdlSurface, SDL_FALSE, 0);
-	sdlSurface->format->BitsPerPixel=surface->getBitsPerPixel();
-	sdlSurface->format->BytesPerPixel=surface->getBytesPerPixel();
-	if ((surface->getColorFormat()==video::ECF_R8G8B8) ||
-			(surface->getColorFormat()==video::ECF_A8R8G8B8))
-	{
-		sdlSurface->format->Rloss=0;
-		sdlSurface->format->Gloss=0;
-		sdlSurface->format->Bloss=0;
-		sdlSurface->format->Rshift=16;
-		sdlSurface->format->Gshift=8;
-		sdlSurface->format->Bshift=0;
-		if (surface->getColorFormat()==video::ECF_R8G8B8)
-		{
-			sdlSurface->format->Aloss=8;
-			sdlSurface->format->Ashift=32;
-		}
-		else
-		{
-			sdlSurface->format->Aloss=0;
-			sdlSurface->format->Ashift=24;
-		}
-	}
-	else if (surface->getColorFormat()==video::ECF_R5G6B5)
-	{
-		sdlSurface->format->Rloss=3;
-		sdlSurface->format->Gloss=2;
-		sdlSurface->format->Bloss=3;
-		sdlSurface->format->Aloss=8;
-		sdlSurface->format->Rshift=11;
-		sdlSurface->format->Gshift=5;
-		sdlSurface->format->Bshift=0;
-		sdlSurface->format->Ashift=16;
-	}
-	else if (surface->getColorFormat()==video::ECF_A1R5G5B5)
-	{
-		sdlSurface->format->Rloss=3;
-		sdlSurface->format->Gloss=3;
-		sdlSurface->format->Bloss=3;
-		sdlSurface->format->Aloss=7;
-		sdlSurface->format->Rshift=10;
-		sdlSurface->format->Gshift=5;
-		sdlSurface->format->Bshift=0;
-		sdlSurface->format->Ashift=15;
-	}
-
-	SDL_Renderer *renderer = SDL_GetRenderer(Sdl2Window);
-	SDL_Texture *sdlTexture = SDL_CreateTextureFromSurface(renderer, sdlSurface);
-	SDL_RenderCopy(renderer, sdlTexture, NULL, NULL);
-	SDL_RenderPresent(renderer);
-	SDL_DestroyTexture(sdlTexture);
-	SDL_FreeSurface(sdlSurface);
-	surface->unlock();
-	return true;
-}
-
-
-//! notifies the device that it should close itself
-void CIrrDeviceSDL2::closeDevice()
-{
-	Close = true;
-}
-
-
-//! \return Pointer to a list with all video modes supported
-video::IVideoModeList* CIrrDeviceSDL2::getVideoModeList()
-{
-	if (!VideoModeList->getVideoModeCount())
-	{
-		// Bah, let's just hope the user is fine with the default resolution
-		//VideoModeList->addMode(core::dimension2d<u32>(800, 600), 24);
-		// NOTE: SDL2 has SDL_GetNumVideoDisplays/SDL_GetWindowDisplayIndex,
-		// SDL_GetNumDisplayModes, SDL_GetDisplayMode
-	}
-
-	return VideoModeList;
-}
-
-
-//! Sets if the window should be resizable in windowed mode.
-void CIrrDeviceSDL2::setResizable(bool resize)
-{
-	if (resize != Resizable)
-	{
-		if (resize)
-			SDL_Flags |= SDL_WINDOW_RESIZABLE;
-		else
-			SDL_Flags &= ~SDL_WINDOW_RESIZABLE;
-		Sdl2Window = createSDL2Window( 0, 0, SDL_Flags );
-		Resizable = resize;
-	}
-}
-
-
-//! Minimizes window if possible
-void CIrrDeviceSDL2::minimizeWindow()
-{
-	SDL_MinimizeWindow(Sdl2Window);
-}
-
-
-//! Maximize window
-void CIrrDeviceSDL2::maximizeWindow()
-{
-	// do nothing
-}
-
-//! Get the position of this window on screen
-core::position2di CIrrDeviceSDL2::getWindowPosition()
-{
-    return core::position2di(-1, -1);
-}
-
-
-//! Restore original window size
-void CIrrDeviceSDL2::restoreWindow()
-{
-	// do nothing
-}
-
-
-//! returns if window is active. if not, nothing need to be drawn
-bool CIrrDeviceSDL2::isWindowActive() const
-{
-	return (WindowHasFocus && !WindowMinimized);
-}
-
-
-//! returns if window has focus.
-bool CIrrDeviceSDL2::isWindowFocused() const
-{
-	return WindowHasFocus;
-}
-
-
-//! returns if window is minimized.
-bool CIrrDeviceSDL2::isWindowMinimized() const
-{
-	return WindowMinimized;
-}
-
-
-//! Set the current Gamma Value for the Display
-bool CIrrDeviceSDL2::setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast )
-{
-	/*
-	// todo: Gamma in SDL takes ints, what does Irrlicht use?
-	return (SDL_SetGamma(red, green, blue) != -1);
-	*/
-	return false;
-}
-
-//! Get the current Gamma Value for the Display
-bool CIrrDeviceSDL2::getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast )
-{
-/*	brightness = 0.f;
-	contrast = 0.f;
-	return (SDL_GetGamma(&red, &green, &blue) != -1);*/
-	return false;
-}
-
-//! returns color format of the window.
-video::ECOLOR_FORMAT CIrrDeviceSDL2::getColorFormat() const
-{
-	// TODO
-	return CIrrDeviceStub::getColorFormat();
-}
-
-
-void CIrrDeviceSDL2::createKeyMap()
-{
-	// I don't know if this is the best method  to create
-	// the lookuptable, but I'll leave it like that until
-	// I find a better version.
-
-	KeyMap.reallocate(105);
-
-	// buttons missing
-
-	KeyMap.push_back(SKeyMap(SDLK_BACKSPACE, KEY_BACK));
-	KeyMap.push_back(SKeyMap(SDLK_TAB, KEY_TAB));
-	KeyMap.push_back(SKeyMap(SDLK_CLEAR, KEY_CLEAR));
-	KeyMap.push_back(SKeyMap(SDLK_RETURN, KEY_RETURN));
-
-	// combined modifiers missing
-
-	KeyMap.push_back(SKeyMap(SDLK_PAUSE, KEY_PAUSE));
-	KeyMap.push_back(SKeyMap(SDLK_CAPSLOCK, KEY_CAPITAL));
-
-	// asian letter keys missing
-
-	KeyMap.push_back(SKeyMap(SDLK_ESCAPE, KEY_ESCAPE));
-
-	// asian letter keys missing
-
-	KeyMap.push_back(SKeyMap(SDLK_SPACE, KEY_SPACE));
-	KeyMap.push_back(SKeyMap(SDLK_PAGEUP, KEY_PRIOR));
-	KeyMap.push_back(SKeyMap(SDLK_PAGEDOWN, KEY_NEXT));
-	KeyMap.push_back(SKeyMap(SDLK_END, KEY_END));
-	KeyMap.push_back(SKeyMap(SDLK_HOME, KEY_HOME));
-	KeyMap.push_back(SKeyMap(SDLK_LEFT, KEY_LEFT));
-	KeyMap.push_back(SKeyMap(SDLK_UP, KEY_UP));
-	KeyMap.push_back(SKeyMap(SDLK_RIGHT, KEY_RIGHT));
-	KeyMap.push_back(SKeyMap(SDLK_DOWN, KEY_DOWN));
-
-	// select missing
-	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_PRINT));
-	// execute missing
-	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_SNAPSHOT));
-
-	KeyMap.push_back(SKeyMap(SDLK_INSERT, KEY_INSERT));
-	KeyMap.push_back(SKeyMap(SDLK_DELETE, KEY_DELETE));
-	KeyMap.push_back(SKeyMap(SDLK_HELP, KEY_HELP));
-
-	KeyMap.push_back(SKeyMap(SDLK_0, KEY_KEY_0));
-	KeyMap.push_back(SKeyMap(SDLK_1, KEY_KEY_1));
-	KeyMap.push_back(SKeyMap(SDLK_2, KEY_KEY_2));
-	KeyMap.push_back(SKeyMap(SDLK_3, KEY_KEY_3));
-	KeyMap.push_back(SKeyMap(SDLK_4, KEY_KEY_4));
-	KeyMap.push_back(SKeyMap(SDLK_5, KEY_KEY_5));
-	KeyMap.push_back(SKeyMap(SDLK_6, KEY_KEY_6));
-	KeyMap.push_back(SKeyMap(SDLK_7, KEY_KEY_7));
-	KeyMap.push_back(SKeyMap(SDLK_8, KEY_KEY_8));
-	KeyMap.push_back(SKeyMap(SDLK_9, KEY_KEY_9));
-
-	KeyMap.push_back(SKeyMap(SDLK_a, KEY_KEY_A));
-	KeyMap.push_back(SKeyMap(SDLK_b, KEY_KEY_B));
-	KeyMap.push_back(SKeyMap(SDLK_c, KEY_KEY_C));
-	KeyMap.push_back(SKeyMap(SDLK_d, KEY_KEY_D));
-	KeyMap.push_back(SKeyMap(SDLK_e, KEY_KEY_E));
-	KeyMap.push_back(SKeyMap(SDLK_f, KEY_KEY_F));
-	KeyMap.push_back(SKeyMap(SDLK_g, KEY_KEY_G));
-	KeyMap.push_back(SKeyMap(SDLK_h, KEY_KEY_H));
-	KeyMap.push_back(SKeyMap(SDLK_i, KEY_KEY_I));
-	KeyMap.push_back(SKeyMap(SDLK_j, KEY_KEY_J));
-	KeyMap.push_back(SKeyMap(SDLK_k, KEY_KEY_K));
-	KeyMap.push_back(SKeyMap(SDLK_l, KEY_KEY_L));
-	KeyMap.push_back(SKeyMap(SDLK_m, KEY_KEY_M));
-	KeyMap.push_back(SKeyMap(SDLK_n, KEY_KEY_N));
-	KeyMap.push_back(SKeyMap(SDLK_o, KEY_KEY_O));
-	KeyMap.push_back(SKeyMap(SDLK_p, KEY_KEY_P));
-	KeyMap.push_back(SKeyMap(SDLK_q, KEY_KEY_Q));
-	KeyMap.push_back(SKeyMap(SDLK_r, KEY_KEY_R));
-	KeyMap.push_back(SKeyMap(SDLK_s, KEY_KEY_S));
-	KeyMap.push_back(SKeyMap(SDLK_t, KEY_KEY_T));
-	KeyMap.push_back(SKeyMap(SDLK_u, KEY_KEY_U));
-	KeyMap.push_back(SKeyMap(SDLK_v, KEY_KEY_V));
-	KeyMap.push_back(SKeyMap(SDLK_w, KEY_KEY_W));
-	KeyMap.push_back(SKeyMap(SDLK_x, KEY_KEY_X));
-	KeyMap.push_back(SKeyMap(SDLK_y, KEY_KEY_Y));
-	KeyMap.push_back(SKeyMap(SDLK_z, KEY_KEY_Z));
-
-	KeyMap.push_back(SKeyMap(SDLK_LGUI, KEY_LWIN));
-	KeyMap.push_back(SKeyMap(SDLK_RGUI, KEY_RWIN));
-	// apps missing
-	KeyMap.push_back(SKeyMap(SDLK_POWER, KEY_SLEEP)); //??
-
-	KeyMap.push_back(SKeyMap(SDLK_KP_0, KEY_NUMPAD0));
-	KeyMap.push_back(SKeyMap(SDLK_KP_1, KEY_NUMPAD1));
-	KeyMap.push_back(SKeyMap(SDLK_KP_2, KEY_NUMPAD2));
-	KeyMap.push_back(SKeyMap(SDLK_KP_3, KEY_NUMPAD3));
-	KeyMap.push_back(SKeyMap(SDLK_KP_4, KEY_NUMPAD4));
-	KeyMap.push_back(SKeyMap(SDLK_KP_5, KEY_NUMPAD5));
-	KeyMap.push_back(SKeyMap(SDLK_KP_6, KEY_NUMPAD6));
-	KeyMap.push_back(SKeyMap(SDLK_KP_7, KEY_NUMPAD7));
-	KeyMap.push_back(SKeyMap(SDLK_KP_8, KEY_NUMPAD8));
-	KeyMap.push_back(SKeyMap(SDLK_KP_9, KEY_NUMPAD9));
-	KeyMap.push_back(SKeyMap(SDLK_KP_MULTIPLY, KEY_MULTIPLY));
-	KeyMap.push_back(SKeyMap(SDLK_KP_PLUS, KEY_ADD));
-//	KeyMap.push_back(SKeyMap(SDLK_KP_, KEY_SEPARATOR));
-	KeyMap.push_back(SKeyMap(SDLK_KP_MINUS, KEY_SUBTRACT));
-	KeyMap.push_back(SKeyMap(SDLK_KP_PERIOD, KEY_DECIMAL));
-	KeyMap.push_back(SKeyMap(SDLK_KP_DIVIDE, KEY_DIVIDE));
-
-	KeyMap.push_back(SKeyMap(SDLK_F1,  KEY_F1));
-	KeyMap.push_back(SKeyMap(SDLK_F2,  KEY_F2));
-	KeyMap.push_back(SKeyMap(SDLK_F3,  KEY_F3));
-	KeyMap.push_back(SKeyMap(SDLK_F4,  KEY_F4));
-	KeyMap.push_back(SKeyMap(SDLK_F5,  KEY_F5));
-	KeyMap.push_back(SKeyMap(SDLK_F6,  KEY_F6));
-	KeyMap.push_back(SKeyMap(SDLK_F7,  KEY_F7));
-	KeyMap.push_back(SKeyMap(SDLK_F8,  KEY_F8));
-	KeyMap.push_back(SKeyMap(SDLK_F9,  KEY_F9));
-	KeyMap.push_back(SKeyMap(SDLK_F10, KEY_F10));
-	KeyMap.push_back(SKeyMap(SDLK_F11, KEY_F11));
-	KeyMap.push_back(SKeyMap(SDLK_F12, KEY_F12));
-	KeyMap.push_back(SKeyMap(SDLK_F13, KEY_F13));
-	KeyMap.push_back(SKeyMap(SDLK_F14, KEY_F14));
-	KeyMap.push_back(SKeyMap(SDLK_F15, KEY_F15));
-	// no higher F-keys
-
-	KeyMap.push_back(SKeyMap(SDLK_NUMLOCKCLEAR, KEY_NUMLOCK));
-	KeyMap.push_back(SKeyMap(SDLK_SCROLLLOCK, KEY_SCROLL));
-	KeyMap.push_back(SKeyMap(SDLK_LSHIFT, KEY_LSHIFT));
-	KeyMap.push_back(SKeyMap(SDLK_RSHIFT, KEY_RSHIFT));
-	KeyMap.push_back(SKeyMap(SDLK_LCTRL,  KEY_LCONTROL));
-	KeyMap.push_back(SKeyMap(SDLK_RCTRL,  KEY_RCONTROL));
-	KeyMap.push_back(SKeyMap(SDLK_LALT,  KEY_LMENU));
-	KeyMap.push_back(SKeyMap(SDLK_RALT,  KEY_RMENU));
-
-	KeyMap.push_back(SKeyMap(SDLK_PLUS,   KEY_PLUS));
-	KeyMap.push_back(SKeyMap(SDLK_COMMA,  KEY_COMMA));
-	KeyMap.push_back(SKeyMap(SDLK_MINUS,  KEY_MINUS));
-	KeyMap.push_back(SKeyMap(SDLK_PERIOD, KEY_PERIOD));
-
-	// some special keys missing
-
-	KeyMap.sort();
-}
-
-} // end namespace irr
-
-#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
-
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "CIrrDeviceSDL2.h"
+#include "IEventReceiver.h"
+#include "irrList.h"
+#include "os.h"
+#include "CTimer.h"
+#include "irrString.h"
+#include "Keycodes.h"
+#include "COSOperator.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "SIrrCreationParameters.h"
+#include <SDL2/SDL_syswm.h>
+#include <SDL2/SDL_video.h>
+
+#include "CEGLManager.h" // Sailfish/c55
+#include <wayland-egl.h>
+
+namespace irr
+{
+	namespace video
+	{
+
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+		IVideoDriver* createDirectX8Driver(const irr::SIrrlichtCreationParameters& params,
+			io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+		IVideoDriver* createDirectX9Driver(const irr::SIrrlichtCreationParameters& params,
+			io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_OPENGL_
+		IVideoDriver* createOpenGLDriver(const SIrrlichtCreationParameters& params,
+				io::IFileSystem* io, CIrrDeviceSDL2* device);
+		#endif
+
+        #ifdef _IRR_COMPILE_WITH_OGLES2_ 	 
+        //IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, video::SExposedVideoData& data, io::IFileSystem* io);
+        IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager);
+        #endif
+	} // end namespace video
+
+} // end namespace irr
+
+
+namespace irr
+{
+
+//! constructor
+CIrrDeviceSDL2::CIrrDeviceSDL2(const SIrrlichtCreationParameters& param)
+	: CIrrDeviceStub(param),
+	Sdl2Window((SDL_Window*)param.WindowId), SDL_Flags(SDL_WINDOW_SHOWN),
+	MouseX(0), MouseY(0), MouseButtonStates(0),
+	Width(param.WindowSize.Width), Height(param.WindowSize.Height),
+	Resizable(false), WindowHasFocus(false), WindowMinimized(false)
+{
+	#ifdef _DEBUG
+	setDebugName("CIrrDeviceSDL2");
+	#endif
+
+	// Initialize SDL... Timer for sleep, video for the obvious, and
+	// noparachute prevents SDL from catching fatal errors.
+	if (SDL_Init( SDL_INIT_TIMER|SDL_INIT_VIDEO|
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+				SDL_INIT_JOYSTICK|
+#endif
+				SDL_INIT_NOPARACHUTE ) < 0)
+	{
+		os::Printer::log( "Unable to initialize SDL!", SDL_GetError());
+		Close = true;
+	}
+
+/*#if defined(_IRR_WINDOWS_)
+	SDL_putenv("SDL_VIDEODRIVER=directx");
+#elif defined(_IRR_OSX_PLATFORM_)
+	SDL_putenv("SDL_VIDEODRIVER=Quartz");
+#else
+	SDL_putenv("SDL_VIDEODRIVER=x11");
+#endif*/
+//	SDL_putenv("SDL_WINDOWID=");
+
+	SDL_VERSION(&Info.version);
+
+	core::stringc sdlversion = "SDL Version ";
+	sdlversion += Info.version.major;
+	sdlversion += ".";
+	sdlversion += Info.version.minor;
+	sdlversion += ".";
+	sdlversion += Info.version.patch;
+
+	Operator = new COSOperator(sdlversion);
+	os::Printer::log(sdlversion.c_str(), ELL_INFORMATION);
+
+	os::Printer::log((core::stringc("SDL2: Number of displays: ")+
+			core::stringc(SDL_GetNumVideoDisplays())).c_str(), ELL_INFORMATION);
+		
+	for(int i=0; i<SDL_GetNumVideoDisplays(); i++){
+		for(int j=0; j<SDL_GetNumDisplayModes(i); j++){
+			SDL_DisplayMode m;
+			SDL_GetDisplayMode(i, j, &m);
+			os::Printer::log((core::stringc("Display ")+core::stringc(i)+
+					core::stringc(" mode ")+core::stringc(j)+
+					core::stringc(": ")+core::stringc(m.w)+
+					core::stringc("x")+core::stringc(m.h)).c_str(), ELL_INFORMATION);
+		}
+	}
+
+	// create keymap
+	createKeyMap();
+
+	if ( CreationParams.Fullscreen )
+		//SDL_Flags |= SDL_WINDOW_FULLSCREEN;
+		SDL_Flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
+	if (CreationParams.DriverType == video::EDT_OPENGL)
+		SDL_Flags |= SDL_WINDOW_OPENGL;
+
+	// create window
+	if (CreationParams.DriverType != video::EDT_NULL)
+	{
+		// create the window, only if we do not use the null device
+		createWindow();
+	}
+
+	// create cursor control
+	CursorControl = new CCursorControl(this);
+
+	// create driver
+	createDriver();
+
+	if (VideoDriver)
+		createGUIAndScene();
+}
+
+
+//! destructor
+CIrrDeviceSDL2::~CIrrDeviceSDL2()
+{
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	const u32 numJoysticks = Joysticks.size();
+	for (u32 i=0; i<numJoysticks; ++i)
+		SDL_JoystickClose(Joysticks[i]);
+#endif
+	SDL_Quit();
+}
+
+static SDL_Window* createSDL2Window(int w, int h, Uint32 flags)
+{
+	return SDL_CreateWindow("Irrlicht/SDL2", SDL_WINDOWPOS_UNDEFINED,
+			SDL_WINDOWPOS_UNDEFINED, w, h, flags);
+}
+
+bool CIrrDeviceSDL2::createWindow()
+{
+	if ( Close )
+		return false;
+
+	if (CreationParams.DriverType == video::EDT_OPENGL)
+	{
+		if (CreationParams.Bits==16)
+		{
+			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?1:0 );
+		}
+		else
+		{
+			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?8:0 );
+		}
+		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, CreationParams.ZBufferBits);
+		if (CreationParams.Doublebuffer)
+			SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+		if (CreationParams.Stereobuffer)
+			SDL_GL_SetAttribute( SDL_GL_STEREO, 1 );
+		if (CreationParams.AntiAlias>1)
+		{
+			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 1 );
+			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
+		}
+		if ( !Sdl2Window )
+			Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+		if ( !Sdl2Window && CreationParams.AntiAlias>1)
+		{
+			while (--CreationParams.AntiAlias>1)
+			{
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
+				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+				if (Sdl2Window)
+					break;
+			}
+			if ( !Sdl2Window )
+			{
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 0 );
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, 0 );
+				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+				if (Sdl2Window)
+					os::Printer::log("AntiAliasing disabled due to lack of support!" );
+			}
+		}
+	}
+	else if ( !Sdl2Window )
+		Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+
+	if ( !Sdl2Window )
+	{
+		os::Printer::log( "Could not initialize display!" );
+		return false;
+	}
+
+	SDL_GetWindowWMInfo(Sdl2Window, &Info);
+	return true;
+}
+
+
+//! create the driver
+void CIrrDeviceSDL2::createDriver()
+{
+	os::Printer::log("CIrrDeviceSDL2::createDriver()", ELL_INFORMATION);
+	switch(CreationParams.DriverType)
+	{
+	case video::EDT_DIRECT3D8:
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+
+		VideoDriver = video::createDirectX8Driver(CreationParams, FileSystem, HWnd);
+		if (!VideoDriver)
+		{
+			os::Printer::log("Could not create DIRECT3D8 Driver.", ELL_ERROR);
+		}
+		#else
+		os::Printer::log("DIRECT3D8 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
+		#endif // _IRR_COMPILE_WITH_DIRECT3D_8_
+
+		break;
+
+	case video::EDT_DIRECT3D9:
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+
+		VideoDriver = video::createDirectX9Driver(CreationParams, FileSystem, HWnd);
+		if (!VideoDriver)
+		{
+			os::Printer::log("Could not create DIRECT3D9 Driver.", ELL_ERROR);
+		}
+		#else
+		os::Printer::log("DIRECT3D9 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
+		#endif // _IRR_COMPILE_WITH_DIRECT3D_9_
+
+		break;
+
+	case video::EDT_SOFTWARE:
+		#ifdef _IRR_COMPILE_WITH_SOFTWARE_
+		VideoDriver = video::createSoftwareDriver(CreationParams.WindowSize, CreationParams.Fullscreen, FileSystem, this);
+		#else
+		os::Printer::log("No Software driver support compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+	case video::EDT_BURNINGSVIDEO:
+		#ifdef _IRR_COMPILE_WITH_BURNINGSVIDEO_
+		VideoDriver = video::createBurningVideoDriver(CreationParams, FileSystem, this);
+		#else
+		os::Printer::log("Burning's video driver was not compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+	case video::EDT_OPENGL:
+		#ifdef _IRR_COMPILE_WITH_OPENGL_
+		VideoDriver = video::createOpenGLDriver(CreationParams, FileSystem, this);
+		#else
+		os::Printer::log("No OpenGL support compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+    case video::EDT_OGLES2: 	 
+        #ifdef _IRR_COMPILE_WITH_OGLES2_
+        {
+            video::SExposedVideoData data;
+			switch(Info.subsystem){
+			case SDL_SYSWM_X11:
+				os::Printer::log("Subsystem for sdl2/ogles2: X11", ELL_INFORMATION);
+			#if defined(SDL_VIDEO_DRIVER_X11)
+				data.OpenGLLinux.X11Window = Info.info.x11.window; // Should be wl_egl_window
+				data.OpenGLLinux.X11Display = Info.info.x11.display;
+			#else
+				os::Printer::log("Subsystem for sdl2/ogles2: X11: not supported", ELL_ERROR);
+			#endif
+				break;
+			case SDL_SYSWM_WAYLAND: {
+				os::Printer::log("Subsystem for sdl2/ogles2: Wayland", ELL_INFORMATION);
+			#if defined(SDL_VIDEO_DRIVER_WAYLAND)
+				void *egl_window = wl_egl_window_create(Info.info.wl.surface, Width, Height);
+				if(!egl_window){
+					os::Printer::log("Wayland: Failed to create EGL window", ELL_ERROR);
+					Close = true;
+					return;
+				}
+				//data.OpenGLLinux.X11Window = (long unsigned int)Info.info.wl.surface; // Should be wl_egl_window
+				data.OpenGLLinux.X11Window = (long unsigned int)egl_window;
+				data.OpenGLLinux.X11Display = Info.info.wl.display;
+			#else
+				os::Printer::log("Subsystem for sdl2/ogles2: Wayland: not supported", ELL_ERROR);
+			#endif
+				break; }
+			case SDL_SYSWM_UNKNOWN:
+				os::Printer::log("Subsystem for sdl2/ogles2: SDL reports unknown: "
+						"not supported", ELL_ERROR);
+				break;
+			default:
+				os::Printer::log("Subsystem for sdl2/ogles2: Unimplemented",
+						ELL_INFORMATION);
+			}
+            ContextManager = new video::CEGLManager();
+			ContextManager->initialize(CreationParams, data);
+            VideoDriver = video::createOGLES2Driver(CreationParams, FileSystem, ContextManager);
+        }
+        #else
+        os::Printer::log("No OpenGL-ES2 support compiled in.", ELL_ERROR); 	 
+        #endif 	 
+        break;
+
+	case video::EDT_NULL:
+		VideoDriver = video::createNullDriver(FileSystem, CreationParams.WindowSize);
+		break;
+
+	default:
+		os::Printer::log("Unable to create video driver of unknown type.", ELL_ERROR);
+		break;
+	}
+}
+
+
+//! runs the device. Returns false if device wants to be deleted
+bool CIrrDeviceSDL2::run()
+{
+	os::Timer::tick();
+
+	SEvent irrevent;
+	SDL_Event sdlevent;
+
+	while ( !Close && SDL_PollEvent( &sdlevent ) )
+	{
+		switch ( sdlevent.type )
+		{
+		case SDL_FINGERDOWN:
+		case SDL_FINGERUP:
+		case SDL_FINGERMOTION:
+			{
+				// TODO: Implement properly
+				irrevent.EventType = EET_MULTI_TOUCH_EVENT;
+				irrevent.MultiTouchInput.clear();
+				bool Touched = false;
+				switch (sdlevent.type)
+				{
+				case SDL_FINGERDOWN:
+					irrevent.MultiTouchInput.Event = EMTIE_PRESSED_DOWN;
+					Touched = true;
+					break;
+				case SDL_FINGERUP:
+					irrevent.MultiTouchInput.Event = EMTIE_LEFT_UP;
+					break;
+				case SDL_FINGERMOTION:
+					irrevent.MultiTouchInput.Event = EMTIE_MOVED;
+					Touched = true;
+					break;
+				default:
+					break;
+				}
+				int i = 0;
+				irrevent.MultiTouchInput.PrevX[i] = sdlevent.tfinger.x - sdlevent.tfinger.dx;
+				irrevent.MultiTouchInput.PrevY[i] = sdlevent.tfinger.y - sdlevent.tfinger.dy;
+				irrevent.MultiTouchInput.X[i] = sdlevent.tfinger.x;
+				irrevent.MultiTouchInput.Y[i] = sdlevent.tfinger.y;
+				irrevent.MultiTouchInput.Touched[i] = Touched;
+				// Note: There's also sdlevent.tfinger.touchId (device id)
+				irrevent.MultiTouchInput.ID[i] = sdlevent.tfinger.fingerId;
+				postEventFromUser(irrevent);
+
+				irrevent = SEvent(); // clear
+				irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+				switch (sdlevent.type)
+				{
+				case SDL_FINGERDOWN:
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
+					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
+					break;
+				case SDL_FINGERUP:
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
+					break;
+				case SDL_FINGERMOTION:
+					irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
+					break;
+				default:
+					break;
+				}
+				irrevent.MouseInput.X = sdlevent.tfinger.x;
+				irrevent.MouseInput.Y = sdlevent.tfinger.y;
+				postEventFromUser(irrevent);
+
+				MouseX = sdlevent.tfinger.x;
+				MouseY = sdlevent.tfinger.y;
+			}
+
+			SDL_StartTextInput(); // Test
+			break;
+
+		case SDL_MOUSEMOTION:
+			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+			MouseX = irrevent.MouseInput.X = sdlevent.motion.x;
+			MouseY = irrevent.MouseInput.Y = sdlevent.motion.y;
+			irrevent.MouseInput.ButtonStates = MouseButtonStates;
+
+			postEventFromUser(irrevent);
+			break;
+
+		case SDL_MOUSEBUTTONDOWN:
+		case SDL_MOUSEBUTTONUP:
+
+			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+			irrevent.MouseInput.X = sdlevent.button.x;
+			irrevent.MouseInput.Y = sdlevent.button.y;
+
+			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+
+			switch(sdlevent.button.button)
+			{
+			case SDL_BUTTON_LEFT:
+				if (sdlevent.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_LEFT;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_LEFT;
+				}
+				break;
+
+			case SDL_BUTTON_RIGHT:
+				if (sdlevent.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_RIGHT;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_RIGHT;
+				}
+				break;
+
+			case SDL_BUTTON_MIDDLE:
+				if (sdlevent.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_MIDDLE;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_MIDDLE;
+				}
+				break;
+
+			/* TODO: Move to SDL_MOUSEWHEEL events
+			case SDL_BUTTON_WHEELUP:
+				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
+				irrevent.MouseInput.Wheel = 1.0f;
+				break;
+
+			case SDL_BUTTON_WHEELDOWN:
+				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
+				irrevent.MouseInput.Wheel = -1.0f;
+				break;*/
+			}
+
+			irrevent.MouseInput.ButtonStates = MouseButtonStates;
+
+			if (irrevent.MouseInput.Event != irr::EMIE_MOUSE_MOVED)
+			{
+				postEventFromUser(irrevent);
+
+				if ( irrevent.MouseInput.Event >= EMIE_LMOUSE_PRESSED_DOWN && irrevent.MouseInput.Event <= EMIE_MMOUSE_PRESSED_DOWN )
+				{
+					u32 clicks = checkSuccessiveClicks(irrevent.MouseInput.X, irrevent.MouseInput.Y, irrevent.MouseInput.Event);
+					if ( clicks == 2 )
+					{
+						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_DOUBLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
+						postEventFromUser(irrevent);
+					}
+					else if ( clicks == 3 )
+					{
+						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_TRIPLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
+						postEventFromUser(irrevent);
+					}
+				}
+			}
+			break;
+
+		case SDL_KEYDOWN:
+		case SDL_KEYUP:
+			{
+				SKeyMap mp;
+				mp.SDLKey = sdlevent.key.keysym.sym;
+				s32 idx = KeyMap.binary_search(mp);
+
+				EKEY_CODE key;
+				if (idx == -1)
+					key = (EKEY_CODE)0;
+				else
+					key = (EKEY_CODE)KeyMap[idx].Win32Key;
+
+#ifdef _IRR_WINDOWS_API_
+				// handle alt+f4 in Windows, because SDL seems not to
+				if ( (sdlevent.key.keysym.mod & KMOD_LALT) && key == KEY_F4)
+				{
+					Close = true;
+					break;
+				}
+#endif
+				irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
+				irrevent.KeyInput.Char = sdlevent.key.keysym.unicode;
+				irrevent.KeyInput.Key = key;
+				irrevent.KeyInput.PressedDown = (sdlevent.type == SDL_KEYDOWN);
+				irrevent.KeyInput.Shift = (sdlevent.key.keysym.mod & KMOD_SHIFT) != 0;
+				irrevent.KeyInput.Control = (sdlevent.key.keysym.mod & KMOD_CTRL ) != 0;
+				postEventFromUser(irrevent);
+			}
+			break;
+
+		case SDL_QUIT:
+			Close = true;
+			break;
+
+		case SDL_WINDOWEVENT:
+			switch (sdlevent.window.event) {
+			case SDL_WINDOWEVENT_SHOWN:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_HIDDEN:
+				break;
+			case SDL_WINDOWEVENT_EXPOSED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_MOVED:
+				break;
+			case SDL_WINDOWEVENT_RESIZED:
+				// NOTE: Can be other window
+				Width = sdlevent.window.data1;
+				Height = sdlevent.window.data2;
+				// TODO: Is this needed?
+				//Sdl2Window = createSDL2Window( Width, Height, 0, SDL_Flags );
+				if (VideoDriver)
+					VideoDriver->OnResize(core::dimension2d<u32>(Width, Height));
+				break;
+			case SDL_WINDOWEVENT_MINIMIZED:
+				WindowMinimized = true;
+				break;
+			case SDL_WINDOWEVENT_MAXIMIZED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_RESTORED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_ENTER:
+				break;
+			case SDL_WINDOWEVENT_LEAVE:
+				break;
+			case SDL_WINDOWEVENT_FOCUS_GAINED:
+				WindowHasFocus = true;
+				break;
+			case SDL_WINDOWEVENT_FOCUS_LOST:
+				WindowHasFocus = false;
+				break;
+			case SDL_WINDOWEVENT_CLOSE:
+				break;
+			default:
+				break;
+			}
+			break;
+
+		case SDL_USEREVENT:
+			irrevent.EventType = irr::EET_USER_EVENT;
+			irrevent.UserEvent.UserData1 = *(reinterpret_cast<s32*>(&sdlevent.user.data1));
+			irrevent.UserEvent.UserData2 = *(reinterpret_cast<s32*>(&sdlevent.user.data2));
+
+			postEventFromUser(irrevent);
+			break;
+
+		default:
+			break;
+		} // end switch
+
+	} // end while
+
+#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	// TODO: Check if the multiple open/close calls are too expensive, then
+	// open/close in the constructor/destructor instead
+
+	// update joystick states manually
+	SDL_JoystickUpdate();
+	// we'll always send joystick input events...
+	SEvent joyevent;
+	joyevent.EventType = EET_JOYSTICK_INPUT_EVENT;
+	for (u32 i=0; i<Joysticks.size(); ++i)
+	{
+		SDL_Joystick* joystick = Joysticks[i];
+		if (joystick)
+		{
+			int j;
+			// query all buttons
+			const int numButtons = core::min_(SDL_JoystickNumButtons(joystick), 32);
+			joyevent.JoystickEvent.ButtonStates=0;
+			for (j=0; j<numButtons; ++j)
+				joyevent.JoystickEvent.ButtonStates |= (SDL_JoystickGetButton(joystick, j)<<j);
+
+			// query all axes, already in correct range
+			const int numAxes = core::min_(SDL_JoystickNumAxes(joystick), SEvent::SJoystickEvent::NUMBER_OF_AXES);
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_X]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Y]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Z]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_R]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_U]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_V]=0;
+			for (j=0; j<numAxes; ++j)
+				joyevent.JoystickEvent.Axis[j] = SDL_JoystickGetAxis(joystick, j);
+
+			// we can only query one hat, SDL only supports 8 directions
+			if (SDL_JoystickNumHats(joystick)>0)
+			{
+				switch (SDL_JoystickGetHat(joystick, 0))
+				{
+					case SDL_HAT_UP:
+						joyevent.JoystickEvent.POV=0;
+						break;
+					case SDL_HAT_RIGHTUP:
+						joyevent.JoystickEvent.POV=4500;
+						break;
+					case SDL_HAT_RIGHT:
+						joyevent.JoystickEvent.POV=9000;
+						break;
+					case SDL_HAT_RIGHTDOWN:
+						joyevent.JoystickEvent.POV=13500;
+						break;
+					case SDL_HAT_DOWN:
+						joyevent.JoystickEvent.POV=18000;
+						break;
+					case SDL_HAT_LEFTDOWN:
+						joyevent.JoystickEvent.POV=22500;
+						break;
+					case SDL_HAT_LEFT:
+						joyevent.JoystickEvent.POV=27000;
+						break;
+					case SDL_HAT_LEFTUP:
+						joyevent.JoystickEvent.POV=31500;
+						break;
+					case SDL_HAT_CENTERED:
+					default:
+						joyevent.JoystickEvent.POV=65535;
+						break;
+				}
+			}
+			else
+			{
+				joyevent.JoystickEvent.POV=65535;
+			}
+
+			// we map the number directly
+			joyevent.JoystickEvent.Joystick=static_cast<u8>(i);
+			// now post the event
+			postEventFromUser(joyevent);
+			// and close the joystick
+		}
+	}
+#endif
+	return !Close;
+}
+
+//! Activate any joysticks, and generate events for them.
+bool CIrrDeviceSDL2::activateJoysticks(core::array<SJoystickInfo> & joystickInfo)
+{
+#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	joystickInfo.clear();
+
+	// we can name up to 256 different joysticks
+	const int numJoysticks = core::min_(SDL_NumJoysticks(), 256);
+	Joysticks.reallocate(numJoysticks);
+	joystickInfo.reallocate(numJoysticks);
+
+	int joystick = 0;
+	for (; joystick<numJoysticks; ++joystick)
+	{
+		Joysticks.push_back(SDL_JoystickOpen(joystick));
+		SJoystickInfo info;
+
+		info.Joystick = joystick;
+		info.Axes = SDL_JoystickNumAxes(Joysticks[joystick]);
+		info.Buttons = SDL_JoystickNumButtons(Joysticks[joystick]);
+		info.Name = SDL_JoystickName(joystick);
+		info.PovHat = (SDL_JoystickNumHats(Joysticks[joystick]) > 0)
+						? SJoystickInfo::POV_HAT_PRESENT : SJoystickInfo::POV_HAT_ABSENT;
+
+		joystickInfo.push_back(info);
+	}
+
+	for(joystick = 0; joystick < (int)joystickInfo.size(); ++joystick)
+	{
+		char logString[256];
+		(void)sprintf(logString, "Found joystick %d, %d axes, %d buttons '%s'",
+		joystick, joystickInfo[joystick].Axes,
+		joystickInfo[joystick].Buttons, joystickInfo[joystick].Name.c_str());
+		os::Printer::log(logString, ELL_INFORMATION);
+	}
+
+	return true;
+
+#endif // _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
+
+	return false;
+}
+
+
+
+//! pause execution temporarily
+void CIrrDeviceSDL2::yield()
+{
+	SDL_Delay(0);
+}
+
+
+//! pause execution for a specified time
+void CIrrDeviceSDL2::sleep(u32 timeMs, bool pauseTimer)
+{
+	const bool wasStopped = Timer ? Timer->isStopped() : true;
+	if (pauseTimer && !wasStopped)
+		Timer->stop();
+
+	SDL_Delay(timeMs);
+
+	if (pauseTimer && !wasStopped)
+		Timer->start();
+}
+
+
+//! sets the caption of the window
+void CIrrDeviceSDL2::setWindowCaption(const wchar_t* text)
+{
+	core::stringc textc = text;
+	SDL_SetWindowTitle(Sdl2Window, textc.c_str());
+}
+
+
+//! presents a surface in the client area
+bool CIrrDeviceSDL2::present(video::IImage* surface, void* windowId, core::rect<s32>* srcClip)
+{
+	SDL_Surface *sdlSurface = SDL_CreateRGBSurfaceFrom(
+			surface->lock(), surface->getDimension().Width, surface->getDimension().Height,
+			surface->getBitsPerPixel(), surface->getPitch(),
+			surface->getRedMask(), surface->getGreenMask(), surface->getBlueMask(), surface->getAlphaMask());
+	if (!sdlSurface)
+		return false;
+	//SDL_SetAlpha(sdlSurface, 0, 0);
+	SDL_SetColorKey(sdlSurface, SDL_FALSE, 0);
+	sdlSurface->format->BitsPerPixel=surface->getBitsPerPixel();
+	sdlSurface->format->BytesPerPixel=surface->getBytesPerPixel();
+	if ((surface->getColorFormat()==video::ECF_R8G8B8) ||
+			(surface->getColorFormat()==video::ECF_A8R8G8B8))
+	{
+		sdlSurface->format->Rloss=0;
+		sdlSurface->format->Gloss=0;
+		sdlSurface->format->Bloss=0;
+		sdlSurface->format->Rshift=16;
+		sdlSurface->format->Gshift=8;
+		sdlSurface->format->Bshift=0;
+		if (surface->getColorFormat()==video::ECF_R8G8B8)
+		{
+			sdlSurface->format->Aloss=8;
+			sdlSurface->format->Ashift=32;
+		}
+		else
+		{
+			sdlSurface->format->Aloss=0;
+			sdlSurface->format->Ashift=24;
+		}
+	}
+	else if (surface->getColorFormat()==video::ECF_R5G6B5)
+	{
+		sdlSurface->format->Rloss=3;
+		sdlSurface->format->Gloss=2;
+		sdlSurface->format->Bloss=3;
+		sdlSurface->format->Aloss=8;
+		sdlSurface->format->Rshift=11;
+		sdlSurface->format->Gshift=5;
+		sdlSurface->format->Bshift=0;
+		sdlSurface->format->Ashift=16;
+	}
+	else if (surface->getColorFormat()==video::ECF_A1R5G5B5)
+	{
+		sdlSurface->format->Rloss=3;
+		sdlSurface->format->Gloss=3;
+		sdlSurface->format->Bloss=3;
+		sdlSurface->format->Aloss=7;
+		sdlSurface->format->Rshift=10;
+		sdlSurface->format->Gshift=5;
+		sdlSurface->format->Bshift=0;
+		sdlSurface->format->Ashift=15;
+	}
+
+	SDL_Renderer *renderer = SDL_GetRenderer(Sdl2Window);
+	SDL_Texture *sdlTexture = SDL_CreateTextureFromSurface(renderer, sdlSurface);
+	SDL_RenderCopy(renderer, sdlTexture, NULL, NULL);
+	SDL_RenderPresent(renderer);
+	SDL_DestroyTexture(sdlTexture);
+	SDL_FreeSurface(sdlSurface);
+	surface->unlock();
+	return true;
+}
+
+
+//! notifies the device that it should close itself
+void CIrrDeviceSDL2::closeDevice()
+{
+	Close = true;
+}
+
+
+//! \return Pointer to a list with all video modes supported
+video::IVideoModeList* CIrrDeviceSDL2::getVideoModeList()
+{
+	if (!VideoModeList->getVideoModeCount())
+	{
+		// Bah, let's just hope the user is fine with the default resolution
+		//VideoModeList->addMode(core::dimension2d<u32>(800, 600), 24);
+		// NOTE: SDL2 has SDL_GetNumVideoDisplays/SDL_GetWindowDisplayIndex,
+		// SDL_GetNumDisplayModes, SDL_GetDisplayMode
+	}
+
+	return VideoModeList;
+}
+
+
+//! Sets if the window should be resizable in windowed mode.
+void CIrrDeviceSDL2::setResizable(bool resize)
+{
+	if (resize != Resizable)
+	{
+		if (resize)
+			SDL_Flags |= SDL_WINDOW_RESIZABLE;
+		else
+			SDL_Flags &= ~SDL_WINDOW_RESIZABLE;
+		Sdl2Window = createSDL2Window( 0, 0, SDL_Flags );
+		Resizable = resize;
+	}
+}
+
+
+//! Minimizes window if possible
+void CIrrDeviceSDL2::minimizeWindow()
+{
+	SDL_MinimizeWindow(Sdl2Window);
+}
+
+
+//! Maximize window
+void CIrrDeviceSDL2::maximizeWindow()
+{
+	// do nothing
+}
+
+//! Get the position of this window on screen
+core::position2di CIrrDeviceSDL2::getWindowPosition()
+{
+    return core::position2di(-1, -1);
+}
+
+
+//! Restore original window size
+void CIrrDeviceSDL2::restoreWindow()
+{
+	// do nothing
+}
+
+
+//! returns if window is active. if not, nothing need to be drawn
+bool CIrrDeviceSDL2::isWindowActive() const
+{
+	return (WindowHasFocus && !WindowMinimized);
+}
+
+
+//! returns if window has focus.
+bool CIrrDeviceSDL2::isWindowFocused() const
+{
+	return WindowHasFocus;
+}
+
+
+//! returns if window is minimized.
+bool CIrrDeviceSDL2::isWindowMinimized() const
+{
+	return WindowMinimized;
+}
+
+
+//! Set the current Gamma Value for the Display
+bool CIrrDeviceSDL2::setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast )
+{
+	/*
+	// todo: Gamma in SDL takes ints, what does Irrlicht use?
+	return (SDL_SetGamma(red, green, blue) != -1);
+	*/
+	return false;
+}
+
+//! Get the current Gamma Value for the Display
+bool CIrrDeviceSDL2::getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast )
+{
+/*	brightness = 0.f;
+	contrast = 0.f;
+	return (SDL_GetGamma(&red, &green, &blue) != -1);*/
+	return false;
+}
+
+//! returns color format of the window.
+video::ECOLOR_FORMAT CIrrDeviceSDL2::getColorFormat() const
+{
+	// TODO
+	return CIrrDeviceStub::getColorFormat();
+}
+
+
+void CIrrDeviceSDL2::createKeyMap()
+{
+	// I don't know if this is the best method  to create
+	// the lookuptable, but I'll leave it like that until
+	// I find a better version.
+
+	KeyMap.reallocate(105);
+
+	// buttons missing
+
+	KeyMap.push_back(SKeyMap(SDLK_BACKSPACE, KEY_BACK));
+	KeyMap.push_back(SKeyMap(SDLK_TAB, KEY_TAB));
+	KeyMap.push_back(SKeyMap(SDLK_CLEAR, KEY_CLEAR));
+	KeyMap.push_back(SKeyMap(SDLK_RETURN, KEY_RETURN));
+
+	// combined modifiers missing
+
+	KeyMap.push_back(SKeyMap(SDLK_PAUSE, KEY_PAUSE));
+	KeyMap.push_back(SKeyMap(SDLK_CAPSLOCK, KEY_CAPITAL));
+
+	// asian letter keys missing
+
+	KeyMap.push_back(SKeyMap(SDLK_ESCAPE, KEY_ESCAPE));
+
+	// asian letter keys missing
+
+	KeyMap.push_back(SKeyMap(SDLK_SPACE, KEY_SPACE));
+	KeyMap.push_back(SKeyMap(SDLK_PAGEUP, KEY_PRIOR));
+	KeyMap.push_back(SKeyMap(SDLK_PAGEDOWN, KEY_NEXT));
+	KeyMap.push_back(SKeyMap(SDLK_END, KEY_END));
+	KeyMap.push_back(SKeyMap(SDLK_HOME, KEY_HOME));
+	KeyMap.push_back(SKeyMap(SDLK_LEFT, KEY_LEFT));
+	KeyMap.push_back(SKeyMap(SDLK_UP, KEY_UP));
+	KeyMap.push_back(SKeyMap(SDLK_RIGHT, KEY_RIGHT));
+	KeyMap.push_back(SKeyMap(SDLK_DOWN, KEY_DOWN));
+
+	// select missing
+	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_PRINT));
+	// execute missing
+	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_SNAPSHOT));
+
+	KeyMap.push_back(SKeyMap(SDLK_INSERT, KEY_INSERT));
+	KeyMap.push_back(SKeyMap(SDLK_DELETE, KEY_DELETE));
+	KeyMap.push_back(SKeyMap(SDLK_HELP, KEY_HELP));
+
+	KeyMap.push_back(SKeyMap(SDLK_0, KEY_KEY_0));
+	KeyMap.push_back(SKeyMap(SDLK_1, KEY_KEY_1));
+	KeyMap.push_back(SKeyMap(SDLK_2, KEY_KEY_2));
+	KeyMap.push_back(SKeyMap(SDLK_3, KEY_KEY_3));
+	KeyMap.push_back(SKeyMap(SDLK_4, KEY_KEY_4));
+	KeyMap.push_back(SKeyMap(SDLK_5, KEY_KEY_5));
+	KeyMap.push_back(SKeyMap(SDLK_6, KEY_KEY_6));
+	KeyMap.push_back(SKeyMap(SDLK_7, KEY_KEY_7));
+	KeyMap.push_back(SKeyMap(SDLK_8, KEY_KEY_8));
+	KeyMap.push_back(SKeyMap(SDLK_9, KEY_KEY_9));
+
+	KeyMap.push_back(SKeyMap(SDLK_a, KEY_KEY_A));
+	KeyMap.push_back(SKeyMap(SDLK_b, KEY_KEY_B));
+	KeyMap.push_back(SKeyMap(SDLK_c, KEY_KEY_C));
+	KeyMap.push_back(SKeyMap(SDLK_d, KEY_KEY_D));
+	KeyMap.push_back(SKeyMap(SDLK_e, KEY_KEY_E));
+	KeyMap.push_back(SKeyMap(SDLK_f, KEY_KEY_F));
+	KeyMap.push_back(SKeyMap(SDLK_g, KEY_KEY_G));
+	KeyMap.push_back(SKeyMap(SDLK_h, KEY_KEY_H));
+	KeyMap.push_back(SKeyMap(SDLK_i, KEY_KEY_I));
+	KeyMap.push_back(SKeyMap(SDLK_j, KEY_KEY_J));
+	KeyMap.push_back(SKeyMap(SDLK_k, KEY_KEY_K));
+	KeyMap.push_back(SKeyMap(SDLK_l, KEY_KEY_L));
+	KeyMap.push_back(SKeyMap(SDLK_m, KEY_KEY_M));
+	KeyMap.push_back(SKeyMap(SDLK_n, KEY_KEY_N));
+	KeyMap.push_back(SKeyMap(SDLK_o, KEY_KEY_O));
+	KeyMap.push_back(SKeyMap(SDLK_p, KEY_KEY_P));
+	KeyMap.push_back(SKeyMap(SDLK_q, KEY_KEY_Q));
+	KeyMap.push_back(SKeyMap(SDLK_r, KEY_KEY_R));
+	KeyMap.push_back(SKeyMap(SDLK_s, KEY_KEY_S));
+	KeyMap.push_back(SKeyMap(SDLK_t, KEY_KEY_T));
+	KeyMap.push_back(SKeyMap(SDLK_u, KEY_KEY_U));
+	KeyMap.push_back(SKeyMap(SDLK_v, KEY_KEY_V));
+	KeyMap.push_back(SKeyMap(SDLK_w, KEY_KEY_W));
+	KeyMap.push_back(SKeyMap(SDLK_x, KEY_KEY_X));
+	KeyMap.push_back(SKeyMap(SDLK_y, KEY_KEY_Y));
+	KeyMap.push_back(SKeyMap(SDLK_z, KEY_KEY_Z));
+
+	KeyMap.push_back(SKeyMap(SDLK_LGUI, KEY_LWIN));
+	KeyMap.push_back(SKeyMap(SDLK_RGUI, KEY_RWIN));
+	// apps missing
+	KeyMap.push_back(SKeyMap(SDLK_POWER, KEY_SLEEP)); //??
+
+	KeyMap.push_back(SKeyMap(SDLK_KP_0, KEY_NUMPAD0));
+	KeyMap.push_back(SKeyMap(SDLK_KP_1, KEY_NUMPAD1));
+	KeyMap.push_back(SKeyMap(SDLK_KP_2, KEY_NUMPAD2));
+	KeyMap.push_back(SKeyMap(SDLK_KP_3, KEY_NUMPAD3));
+	KeyMap.push_back(SKeyMap(SDLK_KP_4, KEY_NUMPAD4));
+	KeyMap.push_back(SKeyMap(SDLK_KP_5, KEY_NUMPAD5));
+	KeyMap.push_back(SKeyMap(SDLK_KP_6, KEY_NUMPAD6));
+	KeyMap.push_back(SKeyMap(SDLK_KP_7, KEY_NUMPAD7));
+	KeyMap.push_back(SKeyMap(SDLK_KP_8, KEY_NUMPAD8));
+	KeyMap.push_back(SKeyMap(SDLK_KP_9, KEY_NUMPAD9));
+	KeyMap.push_back(SKeyMap(SDLK_KP_MULTIPLY, KEY_MULTIPLY));
+	KeyMap.push_back(SKeyMap(SDLK_KP_PLUS, KEY_ADD));
+//	KeyMap.push_back(SKeyMap(SDLK_KP_, KEY_SEPARATOR));
+	KeyMap.push_back(SKeyMap(SDLK_KP_MINUS, KEY_SUBTRACT));
+	KeyMap.push_back(SKeyMap(SDLK_KP_PERIOD, KEY_DECIMAL));
+	KeyMap.push_back(SKeyMap(SDLK_KP_DIVIDE, KEY_DIVIDE));
+
+	KeyMap.push_back(SKeyMap(SDLK_F1,  KEY_F1));
+	KeyMap.push_back(SKeyMap(SDLK_F2,  KEY_F2));
+	KeyMap.push_back(SKeyMap(SDLK_F3,  KEY_F3));
+	KeyMap.push_back(SKeyMap(SDLK_F4,  KEY_F4));
+	KeyMap.push_back(SKeyMap(SDLK_F5,  KEY_F5));
+	KeyMap.push_back(SKeyMap(SDLK_F6,  KEY_F6));
+	KeyMap.push_back(SKeyMap(SDLK_F7,  KEY_F7));
+	KeyMap.push_back(SKeyMap(SDLK_F8,  KEY_F8));
+	KeyMap.push_back(SKeyMap(SDLK_F9,  KEY_F9));
+	KeyMap.push_back(SKeyMap(SDLK_F10, KEY_F10));
+	KeyMap.push_back(SKeyMap(SDLK_F11, KEY_F11));
+	KeyMap.push_back(SKeyMap(SDLK_F12, KEY_F12));
+	KeyMap.push_back(SKeyMap(SDLK_F13, KEY_F13));
+	KeyMap.push_back(SKeyMap(SDLK_F14, KEY_F14));
+	KeyMap.push_back(SKeyMap(SDLK_F15, KEY_F15));
+	// no higher F-keys
+
+	KeyMap.push_back(SKeyMap(SDLK_NUMLOCKCLEAR, KEY_NUMLOCK));
+	KeyMap.push_back(SKeyMap(SDLK_SCROLLLOCK, KEY_SCROLL));
+	KeyMap.push_back(SKeyMap(SDLK_LSHIFT, KEY_LSHIFT));
+	KeyMap.push_back(SKeyMap(SDLK_RSHIFT, KEY_RSHIFT));
+	KeyMap.push_back(SKeyMap(SDLK_LCTRL,  KEY_LCONTROL));
+	KeyMap.push_back(SKeyMap(SDLK_RCTRL,  KEY_RCONTROL));
+	KeyMap.push_back(SKeyMap(SDLK_LALT,  KEY_LMENU));
+	KeyMap.push_back(SKeyMap(SDLK_RALT,  KEY_RMENU));
+
+	KeyMap.push_back(SKeyMap(SDLK_PLUS,   KEY_PLUS));
+	KeyMap.push_back(SKeyMap(SDLK_COMMA,  KEY_COMMA));
+	KeyMap.push_back(SKeyMap(SDLK_MINUS,  KEY_MINUS));
+	KeyMap.push_back(SKeyMap(SDLK_PERIOD, KEY_PERIOD));
+
+	// some special keys missing
+
+	KeyMap.sort();
+}
+
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
diff --git a/source/Irrlicht/CIrrDeviceSDL2.h b/source/Irrlicht/CIrrDeviceSDL2.h
index c7d0672..8f29679 100644
--- a/source/Irrlicht/CIrrDeviceSDL2.h
+++ b/source/Irrlicht/CIrrDeviceSDL2.h
@@ -1,240 +1,240 @@
-// Copyright (C) 2002-2012 Nikolaus Gebhardt
-// This file is part of the "Irrlicht Engine".
-// For conditions of distribution and use, see copyright notice in irrlicht.h
-// This device code is based on the original SDL device implementation
-// contributed by Shane Parker (sirshane).
-
-#ifndef __C_IRR_DEVICE_SDL2_H_INCLUDED__
-#define __C_IRR_DEVICE_SDL2_H_INCLUDED__
-
-#include "IrrCompileConfig.h"
-
-#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
-
-#include "IrrlichtDevice.h"
-#include "CIrrDeviceStub.h"
-#include "IImagePresenter.h"
-#include "ICursorControl.h"
-
-#define SDL_MAIN_HANDLED
-#include <SDL2/SDL.h>
-#include <SDL2/SDL_syswm.h>
-
-namespace irr
-{
-
-	class CIrrDeviceSDL2 : public CIrrDeviceStub, video::IImagePresenter
-	{
-	public:
-
-		//! constructor
-		CIrrDeviceSDL2(const SIrrlichtCreationParameters& param);
-
-		//! destructor
-		virtual ~CIrrDeviceSDL2();
-
-		//! runs the device. Returns false if device wants to be deleted
-		virtual bool run();
-
-		//! pause execution temporarily
-		virtual void yield();
-
-		//! pause execution for a specified time
-		virtual void sleep(u32 timeMs, bool pauseTimer);
-
-		//! sets the caption of the window
-		virtual void setWindowCaption(const wchar_t* text);
-
-		//! returns if window is active. if not, nothing need to be drawn
-		virtual bool isWindowActive() const;
-
-		//! returns if window has focus.
-		bool isWindowFocused() const;
-
-		//! returns if window is minimized.
-		bool isWindowMinimized() const;
-
-		//! returns color format of the window.
-		video::ECOLOR_FORMAT getColorFormat() const;
-
-		//! presents a surface in the client area
-		virtual bool present(video::IImage* surface, void* windowId=0, core::rect<s32>* src=0);
-
-		//! notifies the device that it should close itself
-		virtual void closeDevice();
-
-		//! \return Returns a pointer to a list with all video modes supported
-		video::IVideoModeList* getVideoModeList();
-
-		//! Sets if the window should be resizable in windowed mode.
-		virtual void setResizable(bool resize=false);
-
-		//! Minimizes the window.
-		virtual void minimizeWindow();
-
-		//! Maximizes the window.
-		virtual void maximizeWindow();
-
-		//! Restores the window size.
-		virtual void restoreWindow();
-
-		//! Get the position of this window on screen
-		virtual core::position2di getWindowPosition();
-
-		//! Activate any joysticks, and generate events for them.
-		virtual bool activateJoysticks(core::array<SJoystickInfo> & joystickInfo);
-
-		//! Set the current Gamma Value for the Display
-		virtual bool setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast );
-
-		//! Get the current Gamma Value for the Display
-		virtual bool getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast );
-
-		//! Get the device type
-		virtual E_DEVICE_TYPE getType() const
-		{
-				return EIDT_SDL;
-		}
-
-		//! Implementation of the linux cursor control
-		class CCursorControl : public gui::ICursorControl
-		{
-		public:
-
-			CCursorControl(CIrrDeviceSDL2* dev)
-				: Device(dev), IsVisible(true)
-			{
-			}
-
-			//! Changes the visible state of the mouse cursor.
-			virtual void setVisible(bool visible)
-			{
-				IsVisible = visible;
-				if ( visible )
-					SDL_ShowCursor( SDL_ENABLE );
-				else
-					SDL_ShowCursor( SDL_DISABLE );
-			}
-
-			//! Returns if the cursor is currently visible.
-			virtual bool isVisible() const
-			{
-				return IsVisible;
-			}
-
-			//! Sets the new position of the cursor.
-			virtual void setPosition(const core::position2d<f32> &pos)
-			{
-				setPosition(pos.X, pos.Y);
-			}
-
-			//! Sets the new position of the cursor.
-			virtual void setPosition(f32 x, f32 y)
-			{
-				setPosition((s32)(x*Device->Width), (s32)(y*Device->Height));
-			}
-
-			//! Sets the new position of the cursor.
-			virtual void setPosition(const core::position2d<s32> &pos)
-			{
-				setPosition(pos.X, pos.Y);
-			}
-
-			//! Sets the new position of the cursor.
-			virtual void setPosition(s32 x, s32 y)
-			{
-				// NOTE: There are better ways in SDL2 (relative mode)
-				SDL_WarpMouseInWindow(NULL, x, y);
-			}
-
-			//! Returns the current position of the mouse cursor.
-			virtual const core::position2d<s32>& getPosition()
-			{
-				updateCursorPos();
-				return CursorPos;
-			}
-
-			//! Returns the current position of the mouse cursor.
-			virtual core::position2d<f32> getRelativePosition()
-			{
-				updateCursorPos();
-				return core::position2d<f32>(CursorPos.X / (f32)Device->Width,
-					CursorPos.Y / (f32)Device->Height);
-			}
-
-			virtual void setReferenceRect(core::rect<s32>* rect=0)
-			{
-			}
-
-		private:
-
-			void updateCursorPos()
-			{
-				CursorPos.X = Device->MouseX;
-				CursorPos.Y = Device->MouseY;
-
-				if (CursorPos.X < 0)
-					CursorPos.X = 0;
-				if (CursorPos.X > (s32)Device->Width)
-					CursorPos.X = Device->Width;
-				if (CursorPos.Y < 0)
-					CursorPos.Y = 0;
-				if (CursorPos.Y > (s32)Device->Height)
-					CursorPos.Y = Device->Height;
-			}
-
-			CIrrDeviceSDL2* Device;
-			core::position2d<s32> CursorPos;
-			bool IsVisible;
-		};
-
-	private:
-
-		//! create the driver
-		void createDriver();
-
-		bool createWindow();
-
-		void createKeyMap();
-
-		SDL_Window* Sdl2Window;
-		int SDL_Flags;
-#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
-		core::array<SDL_Joystick*> Joysticks;
-#endif
-
-		s32 MouseX, MouseY;
-		u32 MouseButtonStates;
-
-		u32 Width, Height;
-
-		bool Resizable;
-		bool WindowHasFocus;
-		bool WindowMinimized;
-
-		struct SKeyMap
-		{
-			SKeyMap() {}
-			SKeyMap(s32 x11, s32 win32)
-				: SDLKey(x11), Win32Key(win32)
-			{
-			}
-
-			s32 SDLKey;
-			s32 Win32Key;
-
-			bool operator<(const SKeyMap& o) const
-			{
-				return SDLKey<o.SDLKey;
-			}
-		};
-
-		core::array<SKeyMap> KeyMap;
-		SDL_SysWMinfo Info;
-	};
-
-} // end namespace irr
-
-#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
-#endif // __C_IRR_DEVICE_SDL2_H_INCLUDED__
-
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+// This device code is based on the original SDL device implementation
+// contributed by Shane Parker (sirshane).
+
+#ifndef __C_IRR_DEVICE_SDL2_H_INCLUDED__
+#define __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "IrrlichtDevice.h"
+#include "CIrrDeviceStub.h"
+#include "IImagePresenter.h"
+#include "ICursorControl.h"
+
+#define SDL_MAIN_HANDLED
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_syswm.h>
+
+namespace irr
+{
+
+	class CIrrDeviceSDL2 : public CIrrDeviceStub, video::IImagePresenter
+	{
+	public:
+
+		//! constructor
+		CIrrDeviceSDL2(const SIrrlichtCreationParameters& param);
+
+		//! destructor
+		virtual ~CIrrDeviceSDL2();
+
+		//! runs the device. Returns false if device wants to be deleted
+		virtual bool run();
+
+		//! pause execution temporarily
+		virtual void yield();
+
+		//! pause execution for a specified time
+		virtual void sleep(u32 timeMs, bool pauseTimer);
+
+		//! sets the caption of the window
+		virtual void setWindowCaption(const wchar_t* text);
+
+		//! returns if window is active. if not, nothing need to be drawn
+		virtual bool isWindowActive() const;
+
+		//! returns if window has focus.
+		bool isWindowFocused() const;
+
+		//! returns if window is minimized.
+		bool isWindowMinimized() const;
+
+		//! returns color format of the window.
+		video::ECOLOR_FORMAT getColorFormat() const;
+
+		//! presents a surface in the client area
+		virtual bool present(video::IImage* surface, void* windowId=0, core::rect<s32>* src=0);
+
+		//! notifies the device that it should close itself
+		virtual void closeDevice();
+
+		//! \return Returns a pointer to a list with all video modes supported
+		video::IVideoModeList* getVideoModeList();
+
+		//! Sets if the window should be resizable in windowed mode.
+		virtual void setResizable(bool resize=false);
+
+		//! Minimizes the window.
+		virtual void minimizeWindow();
+
+		//! Maximizes the window.
+		virtual void maximizeWindow();
+
+		//! Restores the window size.
+		virtual void restoreWindow();
+
+		//! Get the position of this window on screen
+		virtual core::position2di getWindowPosition();
+
+		//! Activate any joysticks, and generate events for them.
+		virtual bool activateJoysticks(core::array<SJoystickInfo> & joystickInfo);
+
+		//! Set the current Gamma Value for the Display
+		virtual bool setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast );
+
+		//! Get the current Gamma Value for the Display
+		virtual bool getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast );
+
+		//! Get the device type
+		virtual E_DEVICE_TYPE getType() const
+		{
+				return EIDT_SDL;
+		}
+
+		//! Implementation of the linux cursor control
+		class CCursorControl : public gui::ICursorControl
+		{
+		public:
+
+			CCursorControl(CIrrDeviceSDL2* dev)
+				: Device(dev), IsVisible(true)
+			{
+			}
+
+			//! Changes the visible state of the mouse cursor.
+			virtual void setVisible(bool visible)
+			{
+				IsVisible = visible;
+				if ( visible )
+					SDL_ShowCursor( SDL_ENABLE );
+				else
+					SDL_ShowCursor( SDL_DISABLE );
+			}
+
+			//! Returns if the cursor is currently visible.
+			virtual bool isVisible() const
+			{
+				return IsVisible;
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(const core::position2d<f32> &pos)
+			{
+				setPosition(pos.X, pos.Y);
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(f32 x, f32 y)
+			{
+				setPosition((s32)(x*Device->Width), (s32)(y*Device->Height));
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(const core::position2d<s32> &pos)
+			{
+				setPosition(pos.X, pos.Y);
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(s32 x, s32 y)
+			{
+				// NOTE: There are better ways in SDL2 (relative mode)
+				SDL_WarpMouseInWindow(NULL, x, y);
+			}
+
+			//! Returns the current position of the mouse cursor.
+			virtual const core::position2d<s32>& getPosition()
+			{
+				updateCursorPos();
+				return CursorPos;
+			}
+
+			//! Returns the current position of the mouse cursor.
+			virtual core::position2d<f32> getRelativePosition()
+			{
+				updateCursorPos();
+				return core::position2d<f32>(CursorPos.X / (f32)Device->Width,
+					CursorPos.Y / (f32)Device->Height);
+			}
+
+			virtual void setReferenceRect(core::rect<s32>* rect=0)
+			{
+			}
+
+		private:
+
+			void updateCursorPos()
+			{
+				CursorPos.X = Device->MouseX;
+				CursorPos.Y = Device->MouseY;
+
+				if (CursorPos.X < 0)
+					CursorPos.X = 0;
+				if (CursorPos.X > (s32)Device->Width)
+					CursorPos.X = Device->Width;
+				if (CursorPos.Y < 0)
+					CursorPos.Y = 0;
+				if (CursorPos.Y > (s32)Device->Height)
+					CursorPos.Y = Device->Height;
+			}
+
+			CIrrDeviceSDL2* Device;
+			core::position2d<s32> CursorPos;
+			bool IsVisible;
+		};
+
+	private:
+
+		//! create the driver
+		void createDriver();
+
+		bool createWindow();
+
+		void createKeyMap();
+
+		SDL_Window* Sdl2Window;
+		int SDL_Flags;
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+		core::array<SDL_Joystick*> Joysticks;
+#endif
+
+		s32 MouseX, MouseY;
+		u32 MouseButtonStates;
+
+		u32 Width, Height;
+
+		bool Resizable;
+		bool WindowHasFocus;
+		bool WindowMinimized;
+
+		struct SKeyMap
+		{
+			SKeyMap() {}
+			SKeyMap(s32 x11, s32 win32)
+				: SDLKey(x11), Win32Key(win32)
+			{
+			}
+
+			s32 SDLKey;
+			s32 Win32Key;
+
+			bool operator<(const SKeyMap& o) const
+			{
+				return SDLKey<o.SDLKey;
+			}
+		};
+
+		core::array<SKeyMap> KeyMap;
+		SDL_SysWMinfo Info;
+	};
+
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+#endif // __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
-- 
1.8.4.2

